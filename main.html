


<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Battleship (Eric Lewis)</title>
        
        <style>
            .border {
                border: 3px solid #555;
            }

            text {
                user-select: none;
            }
        </style>

	</head>

	<body>


        <h1>Battleship implemented by Eric Lewis</h1>

        <!-- <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> -->

        

        <svg id="main-svg" width="800" height="500" class="border">

            <!-- <circle id="cir" cx="200" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow"></circle>

            <circle id="cir2" cx="200" cy="50" r="20" stroke="black" stroke-width="2" fill="red"></circle> -->

            <!-- <text x="50" y="50" text-anchor="middle">hello world!</text> -->

            <!-- <rect x="500" y="200" width="100" height="100" fill="blue">
                <circle cx="50" cy="75" r="30" fill="green"></circle>
            </rect> -->


        </svg>
    
    </body>

    <script>

"use strict";


var mainSVG = document.getElementById("main-svg");

function clearMainSVG() {
    while (mainSVG.firstChild) {
        mainSVG.removeChild(mainSVG.firstChild);
    }
}


const tileSize = 40;
const gridOffset = 75;

const textOffset = gridOffset - tileSize/8;
const fontSize = tileSize / 2;

const letters = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]


const tileStandardColor = "lightblue";
const tileSelectedColor = "darkblue";


const pegEmptyR = tileSize/20;
const pegHitR = tileSize/4;
const pegMissR = tileSize/4;

const pegEmptyColor = "black";
const pegHitColor = "red";
const pegMissColor = "white";



function drawCircle(cx, cy, r, fill, stroke, strokeWidth) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    element.setAttribute("cx", cx);
    element.setAttribute("cy", cy);
    element.setAttribute("r", r);

    if(fill) {
        element.setAttribute("fill", fill);
    }
    if(stroke) {
        element.setAttribute("stroke", stroke);
    }
    if(strokeWidth) {
        element.setAttribute("stroke-width", strokeWidth);
    }
    mainSVG.appendChild(element);
    return element;
}

function drawEllipse(cx, cy, rx, ry, fill, stroke, strokeWidth) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    element.setAttribute("cx", cx);
    element.setAttribute("cy", cy);
    element.setAttribute("rx", rx);
    element.setAttribute("ry", ry);

    if(fill) {
        element.setAttribute("fill", fill);
    }
    if(stroke) {
        element.setAttribute("stroke", stroke);
    }
    if(strokeWidth) {
        element.setAttribute("stroke-width", strokeWidth);
    }
    mainSVG.appendChild(element);
    return element;
}

function drawRect(x, y, w, h, fill, stroke, strokeWidth) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    element.setAttribute("x", x);
    element.setAttribute("y", y);
    element.setAttribute("width", w);
    element.setAttribute("height", h);

    if(fill) {
        element.setAttribute("fill", fill);
    }
    if(stroke) {
        element.setAttribute("stroke", stroke);
    }
    if(strokeWidth) {
        element.setAttribute("stroke-width", strokeWidth);
    }
    mainSVG.appendChild(element);
    return element;
}

function drawText(text, x, y, alignH, alignV, fill) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", "text");
    element.setAttribute("x", x);
    element.setAttribute("y", y);

    element.textContent = text;

    if(alignH) {
        if(alignH == "left") {
            alignH = "start";
        } else if(alignH == "right") {
            alignH = "end";
        }
        element.setAttribute("text-anchor", alignH);
    }
    if(alignV) {
        element.setAttribute("dominant-baseline", alignV);
    }
    if(fill) {
        element.setAttribute("fill", alignV);
    }
    mainSVG.appendChild(element);
    return element;
}


function nullSelect(element) {
    element.style.pointerEvents = "none";
}




function getTileDescriptor(x, y) {
    return letters[y] + (x+1)
}

function initTile(element, x, y) {
    element.setAttribute("id", "tile-" + getTileDescriptor(x, y));

    function handleMouseOver() {
        element.setAttribute("fill", tileSelectedColor);
    }
    function handleMouseOut() {
        element.setAttribute("fill", tileStandardColor);
    }
    function handleClick() {
        // element.setAttribute("fill", "grey");

        var outcome = handleShotFired(x, y);

        var peg = document.getElementById("peg-" + getTileDescriptor(x, y));

        updatePeg(peg, x, y);
    }

    element.addEventListener("mouseover", handleMouseOver);
    element.addEventListener("mouseout", handleMouseOut);
    element.addEventListener("click", handleClick);
    
}

function initPeg(element, x, y) {
    element.setAttribute("id", "peg-" + getTileDescriptor(x, y));

    nullSelect(element);
}

function updatePeg(element, x, y) {
    var status = shotMap[x+y*10];

    if(status == "hit") {
        element.setAttribute("r", pegHitR);
        element.setAttribute("fill", pegHitColor);
    } else if(status == "miss") {
        element.setAttribute("r", pegMissR);
        element.setAttribute("fill", pegMissColor);
    } else {
        element.setAttribute("r", pegEmptyR);
        element.setAttribute("fill", pegEmptyColor);
    }
}



// initTile(mainSVG, -100, 5678);



class Ship {
    constructor(length, x, y, rotation) {
        this.length = length;
        this.x = x;
        this.y = y;
        this.rotation = rotation;
    }

    dx() {
        return [
            1, 0, -1, 0
        ][this.rotation];
    }
    dy() {
        return [
            0, 1, 0, -1
        ][this.rotation];
    }

    cx() {
        return this.x + (this.length-1)*this.dx()/2;
    }
    cy() {
        return this.y + (this.length-1)*this.dy()/2;
    }

    points() {
        var x = this.x;
        var y = this.y;

        var p = [];
        for(let i=0; i<this.length; i++) {
            p.push([x, y]);

            x += this.dx();
            y += this.dy();
        }
        return p;
    }

    draw() {
        var margin = tileSize*0.1;
        
        var w = this.length;
        var h = this.length;

        if(!this.dx()) { w = 1; }
        if(!this.dy()) { h = 1; }

        nullSelect(drawEllipse(tileToPixel(this.cx()+0.5), tileToPixel(this.cy()+0.5), w*tileSize/2-margin, h*tileSize/2-margin, "darkgrey")); //, "rgba(0, 0, 0, 0)", "blue"));
    }

    addToShipMap() {
        this.points().forEach(p => {
            shipMap[p[0]+p[1]*10] = "ship";
        });
    }
}
var ships = [];


// instead of [x][y] it is [x+y*10]
var shipMap = [];
var shotMap = [];

// values are empty and ship
for(let i=0; i<100; i++) {
    shipMap.push("empty");
}


const shipLengths = [5, 4, 4, 3, 2];

function newRandomShip(length) {
    for(let test=0; test<1000; test++) {
        let startX = Math.floor(Math.random() * 10);
        let startY = Math.floor(Math.random() * 10);
        let rotation = Math.floor(Math.random() * 4)

        let s = new Ship(length, startX, startY, rotation);

        let valid = true;
        s.points().forEach(p => {
            var [x, y] = p;
            if(x < 0 || x >= 10 || y < 0 || y >= 10 || shipMap[x+y*10] == "ship") {
                valid = false;
                return;
            }
        });
        if(!valid) { continue; }

        
        // console.log("before");
        // s.points().forEach(p => {
        //     console.log(x, y, shipMap[x+y*10]);
        // });

        ships.push(s);
        s.addToShipMap();
        // console.log(x, y);
        
        // console.log("after");
        // s.points().forEach(p => {
        //     console.log(x, y, shipMap[x+y*10]);
        // });

        return true;
    }
    return false;
}

shipLengths.forEach(length => {
    newRandomShip(length);
});


// values are unknown, hit, and miss
for(let i=0; i<100; i++) {
    shotMap.push("unknown");
}

function handleShotFired(x, y) {
    var outcome = "miss";
    if(shipMap[x+y*10] == "ship") {
        outcome = "hit"
    }
    shotMap[x+y*10] = outcome;
    return outcome;
}

function handleMapClick() {

}



function tileToPixel(xOrY) {
    return xOrY*tileSize + gridOffset;
}



function drawMap() {

    // text and tiles

    for(var x=0; x<10; x++) {
        let rx = tileToPixel(x);
        let cx = rx + tileSize/2;

        drawText(x+1, cx, textOffset, "middle").setAttribute("font-size", fontSize, "black");

        for(let y=0; y<10; y++) {
            let ry = tileToPixel(y);
            let cy = ry + tileSize/2;

            // let tile = drawRect(rx, ry, tileSize, tileSize, tileStandardColor, "black", 1);




            if(shipMap[x+y*10] == "ship") {
                var tile = drawRect(rx, ry, tileSize, tileSize, tileSelectedColor, "black", 1);
            } else {
                var tile = drawRect(rx, ry, tileSize, tileSize, tileStandardColor, "black", 1);
            }




            initTile(tile, x, y);
        }
    }


    // ships
    
    ships.forEach(s => {
        s.draw();
    })


    // pegs

    for(var x=0; x<10; x++) {
        let rx = tileToPixel(x);
        let cx = rx + tileSize/2;

        for(let y=0; y<10; y++) {
            let ry = tileToPixel(y);
            let cy = ry + tileSize/2;

            let peg = drawCircle(cx, cy, pegEmptyR, pegEmptyColor);
            initPeg(peg, x, y);
        }
    }

    for(let y=0; y<10; y++) {
        let ry = y*tileSize + gridOffset
        let cy = ry + tileSize/2

        drawText(letters[y], textOffset, cy, "right", "middle").setAttribute("font-size", fontSize, "black");
    }

}
drawMap();








function test() {



    // ships[0].rotation = (ships[0].rotation + 1) % 4
    
    
    const para = document.createElement("p");
    para.innerText = "This is a paragraph";
    document.body.appendChild(para);



    newRandomShip(8);

    clearMainSVG();
    drawMap();



    // // var mainSVG = document.getElementById("main-svg");
    // // // mainSVG.innerHTML = "Hello World!";

    // var x = 250;
    // var y = 300;
    // var r = 30;
    // var stroke = "green";
    // var strokeWidth = 4;
    // var fill = "blue";

    // var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    // circle.setAttributeNS(null, "cx", x);
    // circle.setAttributeNS(null, "cy", y);
    // circle.setAttributeNS(null, "r", r)
    // circle.setAttributeNS(null, "stroke", stroke);
    // circle.setAttributeNS(null, "stroke-width", strokeWidth);
    // circle.setAttributeNS(null, "fill", fill);
    // mainSVG.appendChild(circle);

    // // document.getElementById("main-svg").appendChild(circle);

    // var c = document.getElementById("cir");




    // c.setAttributeNS(null, "cx", Number(c.getAttributeNS(null, "cx")) + 50);

    // console.log(c)
    // console.log(circle)

    // console.log(mainSVG)
    
    // mainSVG.appendChild(circle);

    // console.log(mainSVG)

}


    </script>

    <br/>
    <br/>
    <button onclick="test()">test</button>
    <div>hello world</div> <div>testing</div>
</html>

